[Rust Documentation](https://doc.rust-lang.org/stable/book/title-page.html)

1. Getting Started

- [ ] Installation
- [ ] Hello, World!
- [ ] Hello, Cargo!

2. Common Programming Concepts

- [ ] Variables and Mutability
- [ ] Data Types
- [ ] Functions
- [ ] Comments
- [ ] Control Flow

3. Understanding Ownership

- [ ] What is Ownership?
- [ ] References and Borrowing
- [ ] The Slice Type

4. Using Structs to Structure Related Data

- [ ] Defining and Instantiating Structs
- [ ] An Example Program Using Structs
- [ ] Method Syntax

5. Enums and Pattern Matching

- [ ] Defining an Enum
- [ ] The match Control Flow Construct
- [ ] Concise Control Flow with if let and let else

6. Managing Growing Projects with Packages, Crates, and Modules

- [ ] Packages and Crates
- [ ] Defining Modules to Control Scope and Privacy
- [ ] Paths for Referring to an Item in the Module Tree
- [ ] Bringing Paths Into Scope with the use Keyword
- [ ] Separating Modules into Different Files

7. Common Collections

- [ ] Storing Lists of Values with Vectors
- [ ] Storing UTF-8 Encoded Text with Strings
- [ ] Storing Keys with Associated Values in Hash Maps

8. Error Handling

- [ ] Unrecoverable Errors with panic!
- [ ] Recoverable Errors with Result
- [ ] To panic! or Not to panic!

9. Generic Types, Traits, and Lifetimes

- [ ] Generic Data Types
- [ ] Traits: Defining Shared Behavior
- [ ] Validating References with Lifetimes

10. Writing Automated Tests

- [ ] How to Write Tests
- [ ] Controlling How Tests Are Run
- [ ] Test Organization

11. An I/O Project: Building a Command Line Program

- [ ] Accepting Command Line Arguments
- [ ] Reading a File
- [ ] Refactoring to Improve Modularity and Error Handling
- [ ] Developing the Libraryâ€™s Functionality with Test Driven Development
- [ ] Working with Environment Variables
- [ ] Writing Error Messages to Standard Error Instead of Standard Output

12. Functional Language Features: Iterators and Closures

- [ ] Closures: Anonymous Functions that Capture Their Environment
- [ ] Processing a Series of Items with Iterators
- [ ] Improving Our I/O Project
- [ ] Comparing Performance: Loops vs. Iterators

13. More about Cargo and Crates.io

- [ ] Customizing Builds with Release Profiles
- [ ] Publishing a Crate to Crates.io
- [ ] Cargo Workspaces
- [ ] Installing Binaries from Crates.io with cargo install
- [ ] Extending Cargo with Custom Commands

14. Smart Pointers

- [ ] Using Box`<T>` to Point to Data on the Heap
- [ ] Treating Smart Pointers Like Regular References with Deref
- [ ] Running Code on Cleanup with the Drop Trait
- [ ] Rc`<T>`, the Reference Counted Smart Pointer
- [ ] RefCell`<T>` and the Interior Mutability Pattern
- [ ] Reference Cycles Can Leak Memory

15. Fearless Concurrency

- [ ] Using Threads to Run Code Simultaneously
- [ ] Using Message Passing to Transfer Data Between Threads
- [ ] Shared-State Concurrency
- [ ] Extensible Concurrency with the Send and Sync Traits

16. Fundamentals of Asynchronous Programming: Async, Await, Futures, and Streams

- [ ] Futures and the Async Syntax
- [ ] Applying Concurrency with Async
- [ ] Working With Any Number of Futures
- [ ] Streams: Futures in Sequence
- [ ] A Closer Look at the Traits for Async
- [ ] Futures, Tasks, and Threads

17. Object Oriented Programming Features of Rust

- [ ] Characteristics of Object-Oriented Languages
- [ ] Using Trait Objects That Allow for Values of Different Types
- [ ] Implementing an Object-Oriented Design Pattern

18. Patterns and Matching

- [ ] All the Places Patterns Can Be Used
- [ ] Refutability: Whether a Pattern Might Fail to Match
- [ ] Pattern Syntax

19. Advanced Features

- [ ] Unsafe Rust
- [ ] Advanced Traits
- [ ] Advanced Types
- [ ] Advanced Functions and Closures
- [ ] Macros

20. Final Project: Building a Multithreaded Web Server

- [ ] Building a Single-Threaded Web Server
- [ ] Turning Our Single-Threaded Server into a Multithreaded Server
- [ ] Graceful Shutdown and Cleanup
