Regular Languages: These are the simplest class of languages in the
Chomsky hierarchy, and they can be defined using **regular expressions**
or recognized by [[finite automata]].
- A language L over an alphabet Σ is called a regular language if it can be
generated by a regular expression or, equivalently, if it can be accepted
by a finite automaton (deterministic or non-deterministic).
# Regular Expressions
- are a formal notation that defines a regular language.
- specifies a pattern that can be matched by strings over a given alphabet.
# Formalizing
- let $L$ be a function that maps any **regular expression** to the **regular language** that it generates, this function takes:
	- **Input**: A regular expression $R$
	- **Output**: The language $L(R) \subseteq \Sigma^*$ (set of all strings matching $R$)
- so we call $L(R)$ a **regular language** defined by **regular expression** $R$.
- assume $\Sigma$ is an alphabet, $R_1, R_2, R_3, ..., R_n$ are regular expressions, the $L$ function has some properties:
- regular expression matches nothing: $L(\phi) = {\phi}$
- regular expression matches and empty string: $L(\varepsilon) = {\varepsilon}$
- regular expression of a symbol will match that symbol: $L(a) = {a}, \forall a \in alphabet\ \Sigma$
- union of regular expressions: $L(R_1|R_2) = L(R_1) \cup L(R_2)$
- concatenation of regular expressions: $L(R_1R_2) = \{ab\ |\ a \in R_1,\ b \in R_2\}$
- kleene star: $L(R^*) = (L(R))^*$
# Properties
## Union (∪)
If $R_1$ and $R_2$ are regular expressions, then $R_1 \cup R_2$ is also a regular expression.
Example: If $R_1 = a∗$ and $R_2 = b∗$ , then $R_1 \cup R_2$ matches strings made of
any number of a’s or b’s.
## Concatenation
If $R_1$ and $R_2$ are regular expressions, then $R_1 R_2$ is also a regular expression.
Example: If $R_1 = a∗$ and $R_2 = b∗$ , then $R_1 R_2$ matches strings of a’s followed
by b’s.
## Kleene Star (\*)
If $R$ is a regular expression, then $R∗$ is also a regular expression.
Example: If $R = ab$, then $R∗ = (ab)∗$ matches "", "ab", "abab", and so on.
## Intersection (∩)
Regular expressions are closed under intersection. If $L_1$ and $L_2$ are regular
languages, then:
$L_1 \cap L_2$
is also a regular language.
## Complement (ň)
If $L$ is a regular language, then the complement $L$ is also regular:
$L(R) = \Sigma∗\ -\ L(R)$
## Diﬀerence (-)
The diﬀerence of two regular languages is also regular:
$L1 − L2 = L1 \cap L2$
# Matching Binary Strings
## Basic Symbols
• 0 and 1: Match the literal characters 0 and 1.
• ε: Represents the empty string.
• +: Union (logical OR) e.g., 0 + 1 means 0 or 1.
• (r1 )(r2 ): Concatenation of two regular expressions.
• (r)∗ : Kleene star zero or more repetitions of r.
• (r)+ : One or more repetitions of r.
# Applications of Regular Languages
- Lexical Analysis: Token recognition in compilers.
- Text Searching: Pattern matching using tools like grep or regex.
- Protocol Design: Describing simple communication patterns.
- Automated Verification: Model checking of finite-state systems.